use crate::build::{Directory, fat::writer::Writer};

mod writer;

pub fn make(root: &Vec<Directory>) -> Vec<u8> {
    Vec::new()
}

#[derive(Debug, Clone)]
struct BPB {
    /// Count of bytes per sector. This value may take on only the following values: 512, 1024, 2048 or 4096
    bytes_per_sector: u16,
    /// Number of sectors per allocation unit. This value must be a power of 2 that is greater than 0.
    /// The legal values are 1, 2, 4, 8, 16, 32, 64, and 128
    sector_per_cluster: u8,
    /// Number of reserved sectors in the reserved region of the volume starting at the first sector of the volume.
    /// This field is used to align the start of the data area to integral multiples of the cluster size
    /// with respect to the start of the partition/media. This field must not be 0 and can be any non-zero
    /// value. This field should typically be used to align the start of the data area (cluster #2) to the desired
    /// alignment unit, typically cluster size
    reserved_sector_count: u16,
    /// The count of file allocation tables (FATs) on the
    /// volume. A value of 2 is recommended although a
    /// value of 1 is acceptable
    fat_count: u8,
    /// The legal values for this field are 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, and 0xFF.
    /// 0xF8 is the standard value for “fixed” (non-removable) media. For removable media, 0xF0 is
    /// frequently used
    media: u8,
    /// Sectors per track for interrupt 0x13. This field is only relevant for media that have a geometry (volume is broken down into tracks by
    /// multiple heads and cylinders) and are visible on interrupt 0x13.
    sec_per_trk: u16,
    /// Number of heads for interrupt 0x13. This field is relevant as discussed earlier for BPB_SecPerTrk.
    /// This field contains the one based “count of heads”. For example, on a 1.44 MB 3.5-inch floppy drive
    /// this value is 2.
    num_heads: u16,
    /// Count of hidden sectors preceding the partition that contains this FAT volume. This field is generally
    /// only relevant for media visible on interrupt 0x13. This field must always be zero on media that are
    // not partitioned.
    hidden_sector_count: u32,
    /// This field is the 32-bit total count of sectors on the volume.
    /// This count includes the count of all sectors in all four regions of the volume
    total_sector: u32,
    /// This field is the FAT32 32-bit count of sectors occupied by one FAT.
    /// Note that BPB_FATSz16 must be 0 for media formatted FAT32.
    fat_size: u32,
    /// Set as described below:
    /// Bits 0-3 -- Zero-based number of active FAT. Only
    ///             valid if mirroring is disabled.
    /// Bit 7    -- 0 means the FAT is mirrored at runtime into all FATs.
    ///          -- 1 means only one FAT is active; it is the one referenced in bits 0-3.
    /// Bits 4-6 -- Reserved.
    /// Bits 8-15 -- Reserved
    ext_flags: u16,
    /// This is set to the cluster number of the first cluster of the root directory,
    /// This value should be 2 or the first usable (not bad) cluster available thereafter.
    root_cluster: u32,
    /// Sector number of FSINFO structure in the reserved area of the FAT32 volume. Usually 1.
    fs_info: u16,
    /// Set to 0 or 6. If non-zero, indicates the sector number in the reserved area of the volume
    /// of a copy of the bootrecord
    bk_boot_sec: u16,
    /// Interrupt 0x13 drive number. Set value to 0x80 or
    /// 0x00.
    drv_number: u8,
    /// Extended boot signature. Set value to 0x29 if either of the following two fields are non-zero.
    /// This is a signature byte that indicates that the following three fields in the boot sector are present
    boot_signature: u8,
    /// Volume serial number. This field, together with [Self::volume_lable], supports volume tracking on removable media.
    /// These values allow FAT file system drivers to detect that the wrong disk is inserted in a removable drive.
    /// This ID should be generated by simply combining the current date and time into a 32-bit value.
    volume_serial_number: u32,
    /// Volume label. This field matches the 11-byte volume label recorded in the root directory
    volume_label: String,
}

impl BPB {
    pub fn write(&self, writer: &mut Writer) {
        writer.write_u8(0xEB).write_u8(0xFF).write_u8(0x90); // Jmp boot
        writer.write_str_padded("RADIUM", 8); // OEM NAME
        writer.write_u16(self.bytes_per_sector);
        assert!(self.sector_per_cluster.is_power_of_two(), "Sector per cluster is not a power of 2");
        writer.write_u8(self.sector_per_cluster);
        writer.write_u16(self.reserved_sector_count);
        writer.write_u8(self.fat_count);
        writer.write_u16(0); // zero for fat 32
        writer.write_u16(0); // zero for fat 32
        writer.write_u8(self.media);
        writer.write_u16(0); // zero for fat 32
        writer.write_u16(self.sec_per_trk);
        writer.write_u16(self.num_heads);
        writer.write_u32(self.hidden_sector_count);
        writer.write_u32(self.total_sector);
        writer.write_u32(self.fat_size);
        writer.write_u16(self.ext_flags);
        writer.write_u16(0); // Revision
        writer.write_u32(self.root_cluster);
        writer.write_u16(self.fs_info);
        writer.write_u16(self.bk_boot_sec);
        writer.padd(12);
        writer.write_u8(self.drv_number);
        writer.padd(1);
        writer.write_u8(self.boot_signature);
        writer.write_u32(self.volume_serial_number);
        writer.write_str_padded("RADIUM BOOT", 11);
        writer.write_str_padded("FAT32", 8);
        writer.padd(420);
        writer.write_u8(0x55).write_u8(0xAA); // Signature 
        writer.padd(self.bytes_per_sector as usize - 512);
    }
}
